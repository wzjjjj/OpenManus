没问题！欢迎回来 👋。学习编程最重要的是持续性和连贯性，我帮你把前两周的“剧情”串联一下，让你无缝衔接到 Week 3。

### 🔄 前两周剧情回顾 (Previously on OpenManus...)

#### **Week 1：Agent 的“心跳”与“骨架”**
*   **核心成就**：跑通了 Agent 的最小闭环。
*   **关键机制**：
    *   **Loop (循环)**：Agent 的生命周期就是一个巨大的 `while` 循环 (`step 1` -> `step 2` ...)。
    *   **Think (思考)**：Agent 观察当前情况，决定下一步做什么（调用 LLM）。
    *   **Act (行动)**：执行思考的结果（调用工具或返回文本）。
    *   **State (状态)**：Agent 在 `IDLE` -> `RUNNING` -> `FINISHED` 之间流转。

#### **Week 2：Agent 的“手” (工具系统)**
*   **核心成就**：深入解剖了工具系统，并亲手造了工具。
*   **三大支柱**：
    1.  **BaseTool**：工具的“身份证”。每个工具都是一个 Pydantic 对象，自带说明书 (`to_param`)。
    2.  **ToolCollection**：工具的“管家”。它用 O(1) 的哈希表管理所有工具，负责分发任务。
    3.  **分层错误处理**：
        *   第一层（业务层）：`ToolCollection` 捕获 `ToolError` -> 返回失败结果（Agent 依然活着）。
        *   第二层（系统层）：`ToolCallAgent` 捕获所有 `Exception` -> 防止进程崩溃。

---

### 🧠 Week 3 预告：Agent 的“大脑” (记忆系统)

这一周，我们要探究 Agent 是如何**记住**这一切的。

#### **本周核心问题**
1.  **存储结构**：`user` 说的话、`assistant` 的思考、`tool` 的执行结果，它们在内存里到底长什么样？
2.  **上下文管理**：对话越来越长，Token 越来越贵，内存会不会爆？OpenManus 是怎么处理“遗忘”的？
3.  **多态消息**：为什么一条消息里可以既有“文本”又有“工具调用”？

#### **今日任务 (Day 1)**
*   **目标**：精读 `app/schema.py`。
*   **动作**：分析 `Message` 和 `Memory` 类的源码。
*   **思考题**：如果内存满了，简单的“滑动窗口”截断策略会有什么致命缺陷？（比如把 System Prompt 截没了怎么办？）

---

**准备好开始 Week 3 Day 1 的源码分析了吗？** 🚀