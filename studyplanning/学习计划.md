# OpenManus 学习计划（4 周）

适用对象：希望读懂并能改动 OpenManus 的 Python 学习者  
建议投入：每天 1–2 小时，连续 4 周

## 使用方式
- 先通读本文件一次，了解路线与验收标准
- 每周按对应的 `weekX.md` 执行；每天结束时写 5–10 行复盘
- 优先“跑通→读懂最小闭环→再扩展”，不要一上来全量啃代码

## 你要达到的终点
- 能从源码解释一次请求的完整闭环：输入 prompt → 多步循环 → 工具调用 → memory 增长 → 退出与 cleanup
- 能新增/修改一个工具并让 Agent 调用成功（含失败回传）
- 能读懂并改造一个 Flow 的 orchestration 逻辑（比如 executor 选择）
- 能在 Sandbox 或 MCP 里跑通一种“接到真实世界”的执行方式

## 预备（第 0 天：环境与最小可运行）
- 能运行：`python main.py --prompt "用一句话自我介绍并结束"`
- 能定位日志输出位置与关键报错（例如 JSON 参数解析失败、TokenLimitExceeded 等）
- 先不追求配置全套能力（例如 Sandbox/MCP），只保证主入口能跑

## 4 周路线（主线）
- 第 1 周：跑通与读懂最小闭环 → [week1.md](week1.md)
- 第 2 周：工具系统与可扩展点 → [week2.md](week2.md)
- 第 3 周：Flow（规划与多 Agent 编排）→ [week3.md](week3.md)
- 第 4 周：Sandbox / MCP（把 Agent 接到真实世界）→ [week4.md](week4.md)

## 每日固定节奏（强烈建议照做）
- 10 分钟：跑一条最小命令，确保环境没坏
- 40–60 分钟：精读 1 个核心函数（只读一条调用链）
- 20 分钟：写复盘（输入/输出/状态变化/memory 增长点）
- 10 分钟：写 1 个你明天要验证的小假设（例如“tool_message 在哪里入库”）

## 每周交付物（强制输出，保证不白学）
### Week 1 交付物
- 一张时序图：`run -> step -> think/act -> memory -> stop`
- 一份“伪日志复盘”：逐步写出每一步发生了什么

### Week 2 交付物
- 一个最小自定义工具（纯文本/纯计算即可）
- 两条演示：成功调用一次 + 失败一次（异常如何回传）

### Week 3 交付物
- 一个可运行的小改动：不同类型 step 选择不同 executor
- 一份可追踪输出：能从最终输出反查每个 step 的执行摘要

### Week 4 交付物
- 选 Sandbox 或 MCP 跑通一种路线
- 一个只读信息工具在该路线中可用（含失败路径）
- 一页对比总结：本地工具 vs Sandbox vs MCP

## 速查：你需要掌握的 Python 知识（按优先级）
- 异步编程：`async def` / `await` / `asyncio` / 协程与阻塞 I/O
- 面向对象：继承、重写、多态、类属性与实例属性
- 类型标注：`Optional` / `Union` / `List` / `Dict` / `Literal` / `Generic`
- 数据校验：Pydantic 的 `BaseModel` / `Field` / validator
- 反射与动态性：`hasattr` / `getattr` / `callable` / `inspect`
- 异常与日志：`try/except`、错误包装、日志分级
- 序列化：`json.loads/dumps`，以及“工具参数是 JSON 字符串”的约定

## 加速路线（可选）
- 你更偏工程：Week 1–2 做完后，直接做 Week 3 的 executor 选择改造
- 你更偏工具：Week 2 做完后，挑 1–2 个工具精读（browser / web_search / python_execute）
- 你更偏系统：Week 4 选一条路线做深，写清楚资源管理与边界

